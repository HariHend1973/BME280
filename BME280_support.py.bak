#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    Oct 30, 2023 05:56:57 PM +07  platform: Windows NT

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *

import BME280
import ipaddress
import struct
import socket
import re
import string
import codecs
import random
import binascii
import os
import time
import threading
from datetime import datetime

connected = "no"
s = socket.socket()

stop_event = threading.Event()


_debug = True # False to eliminate debug printing from callback functions.

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = BME280.APRS_Telemetry(_top1)
    root.mainloop()

def connect(*args):
    #if _debug:
    #    print('BME280_support.xxx')
    #    for arg in args:
    #        print ('    another arg:', arg)
    #    sys.stdout.flush()
    #_w1.scrlLogs.insert(END, "BME280_support.xxx")
    try:
        s_ipv4 = str(ipaddress.ip_address(_w1.txtKissIp.get()))
    except ValueError:
        s_ipv4 = "Wrong ipv4 format"
    if s_ipv4:
        _w1.scrlLogs.insert(END, dtime() + "IP: " + s_ipv4)

    try:
        s_port = _w1.txtKissPort.get()
        s_port = int(s_port)
    except:
        s_port = 8001

    if _w1.txtKissIp.get() and _w1.txtKissPort.get():
        s = sockconnect(s_ipv4, s_port)
        return s
    else:
        pass

def sockconnect(s_ipv4, s_port):
    global s, connected, sensorpoll, sensorbcn
    if connected == "no":
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        try:
            s.connect((s_ipv4, s_port))
        except socket.error:
            _w1.scrlLogs.insert(END, dtime() + "Caught exception socket.errors")
        _w1.scrlLogs.insert(END, dtime() + "CONNECTED to, IP " + s_ipv4 + " PORT: " + str(s_port))
        _w1.btnConnect.configure(text='''Disconnect''')
        connected = "yes"
        stop_event.clear()
    elif connected == "yes":
        _w1.btnConnect.configure(text='''Connect''')
        _w1.scrlLogs.insert(END, dtime() + "DISCONNECTED")
        connected = "no"
        stop_event.set()
    sensorpoll = threading.Thread(target=get_sensor)
    sensorbcn = threading.Thread(target=sendbcn)
    sensorpoll.daemon = True
    sensorbcn.daemon = True
    sensorpoll.start()
    sensorbcn.start()
    return (s, connected)

def sendbcn():
    old_t=time.time()
    while not stop_event.is_set():
        bcnInterval = 600 
        if time.time()-old_t > bcnInterval:
            s_strbcn=bytes.fromhex(my_bcn)
            _w1.scrlLogs.insert(END, dtime() + "beacon position: " +  binascii.unhexlify("21303631302e3834532f31303635312e3639452d594430424358277320415052532076696120505954484f4e").decode('utf8') + "\n")
            _w1.scrlLogs.insert(END, dtime() + "Beacon Interval: " + str(bcnInterval)  + "\n")
            s.sendall(s_strbcn)
            old_t=time.time()
        time.sleep(1)  # Sleep for 1 second to reduce CPU usage

def dtime():
    now = datetime.now()
    s1 = now.strftime("%m/%d/%Y, %H:%M:%S")
    return ("[" + str(s1) + "] ")

def get_sensor():
    while not stop_event.is_set():
        with open("/home/hari/FT232H/bme280.txt", "r") as f:
            last_line = f.readlines()[-1]
            fields = last_line.split()
            lines = ' '.join(fields[2:10])
            temperature = fields[3][:5]
            humidity = fields[5][:5]
            pressure = fields[7][:7]
            altitude = fields[9][:4]

            # temperature
            _w1.txtTemperature.delete(0, END)  # Clear the existing text
            _w1.txtTemperature.insert(0, temperature + " " + u"\u2103")  # Insert the new temperature

            # humidity
            _w1.txtHumidity.delete(0, END)
            _w1.txtHumidity.insert(0, humidity + " %")

            # pressure
            _w1.txtPressure.delete(0, END)
            _w1.txtPressure.insert(0, pressure + " Pa")

            # altitude
            _w1.txtAltitude.delete(0, END)
            _w1.txtAltitude.insert(0, altitude + " MSL")

            # logs
            _w1.scrlLogs.insert(END, dtime() + lines.strip())
            _w1.scrlLogs.yview(END)
        time.sleep(1)

if __name__ == '__main__':
    BME280.start_up()




