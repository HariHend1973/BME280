#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    Oct 30, 2023 05:56:57 PM +07  platform: Windows NT

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *

import BME280
import ipaddress
import struct
import socket
import re
import string
import codecs
import random
import binascii
import os
import time
import threading
import shlex
from datetime import datetime

connected = "no"
s = socket.socket()
my_bcn="c000A0B29692A6A6e0b288608486b07aae92888a62406303f021303631302e3639532f31303635302e38384557594430424358277320415052532074656c656d657472792076696120505954484f4ec0"
telem_header="c000A0B29692A6A6e0b288608486b07aae92888a62406303f0"
telem_tail="c0"
stop_event = threading.Event()

temperature = ''
humidity = ''
pressure = ''
altitude = ''

_debug = True # False to eliminate debug printing from callback functions.

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = BME280.APRS_Telemetry(_top1)
    root.mainloop()

def connect(*args):
    #if _debug:
    #    print('BME280_support.xxx')
    #    for arg in args:
    #        print ('    another arg:', arg)
    #    sys.stdout.flush()
    #_w1.scrlLogs.insert(END, "BME280_support.xxx")
    try:
        s_ipv4 = str(ipaddress.ip_address(_w1.txtKissIp.get()))
    except ValueError:
        s_ipv4 = "Wrong ipv4 format"
    if s_ipv4:
        _w1.scrlLogs.insert(END, dtime() + "IP: " + s_ipv4)

    try:
        s_port = _w1.txtKissPort.get()
        s_port = int(s_port)
    except:
        s_port = 8001

    if _w1.txtKissIp.get() and _w1.txtKissPort.get():
        s = sockconnect(s_ipv4, s_port)
        return s
    else:
        pass

def sockconnect(s_ipv4, s_port):
    global s, connected, sensorpoll, sensorbcn
    if connected == "no":
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        try:
            s.connect((s_ipv4, s_port))
        except socket.error:
            _w1.scrlLogs.insert(END, dtime() + "Caught exception socket.errors")
        _w1.scrlLogs.insert(END, dtime() + "CONNECTED to, IP " + s_ipv4 + " PORT: " + str(s_port))
        _w1.btnConnect.configure(text='''Disconnect''')
        connected = "yes"
        stop_event.clear()
    elif connected == "yes":
        _w1.btnConnect.configure(text='''Connect''')
        _w1.scrlLogs.insert(END, dtime() + "DISCONNECTED")
        connected = "no"
        stop_event.set()
    sensorpoll = threading.Thread(target=get_sensor)
    sensorbcn = threading.Thread(target=sendbcn)
    sensorpoll.daemon = True
    sensorbcn.daemon = True
    sensorpoll.start()
    sensorbcn.start()
    return (s, connected)

def sendbcn():
    global s, connected
    old_t=time.time()
    while not stop_event.is_set():
        bcnInterval = 600

        if time.time()-old_t > bcnInterval:
            s_seq = telem_seq()
            s_rand_bits = rand_bits(8)
            parm='''Temperature Humidity Pressure Altitude """" SW1 SW2 SW3 SW4 SW5 SW6 SW7 SW8'''
            unit='''deg.C % Pa MSL'''
            eqns='''YD0BCX-13 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0'''
            bits=f'''YD0BCX-13 {s_rand_bits} "YD0BCX telemetry station"'''
            data =f"T#{s_seq} {temperature} {humidity} {pressure} {altitude} 0000 11111111"

            s_strbcn=bytes.fromhex(my_bcn)
            _w1.scrlLogs.insert(END, dtime() + "beacon position: " +  binascii.unhexlify("21303631302e3639532f31303635302e38384557594430424358277320415052532074656c656d657472792076696120505954484f4e").decode('utf8'))
            _w1.scrlLogs.insert(END, dtime() + "Beacon Interval: " + str(bcnInterval))
            try:
                s.sendall(s_strbcn)
            except:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.sendall(s_strbcn)
                connected = "yes"
            old_t=time.time()

            # PARM
            time.sleep(3)
            s_parm = telem_param(parm)
            hex_parm = ascii_to_hex(s_parm)
            s_strparm=bytes.fromhex(telem_header + hex_parm + telem_tail)
            try:
                s.sendall(s_strparm)
            except:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.sendall(s_strparm)
                connected = "yes"
            _w1.scrlLogs.insert(END, dtime() + "PARM=" + str(s_parm))

            # UNIT
            time.sleep(3)
            s_unit = telem_unit(unit)
            hex_unit = ascii_to_hex(s_unit)
            s_strunit=bytes.fromhex(telem_header + hex_unit + telem_tail)
            try:
                s.sendall(s_strunit)
            except:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.sendall(s_strunit)
                connected = "yes"
            _w1.scrlLogs.insert(END, dtime() + "UNIT=" + str(s_unit))

            # EQNS
            time.sleep(3)
            s_eqns = telem_eqns(eqns)
            hex_eqns = ascii_to_hex(s_eqns)
            s_streqns=bytes.fromhex(telem_header + hex_eqns + telem_tail)
            try:
                s.sendall(s_streqns)
            except:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.sendall(s_streqns)
                connected = "yes"
            _w1.scrlLogs.insert(END, dtime() + "EQNS=" + str(s_eqns))

            # DATA
            time.sleep(3)
            s_data = telem_data(data)
            hex_data = ascii_to_hex(s_data)
            s_strdata=bytes.fromhex(telem_header + hex_data + telem_tail)
            try:
                s.sendall(s_strdata)
            except:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.sendall(s_strdata)
                connected = "yes"
            _w1.scrlLogs.insert(END, dtime() + "DATA=" + str(s_data))

            # BITS
            time.sleep(3)
            s_bits = telem_bits(bits)
            hex_bits = ascii_to_hex(s_bits)
            s_strbits=bytes.fromhex(telem_header + hex_bits + telem_tail)
            try:
                s.sendall(s_strbits)
            except:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.sendall(s_strbits)
                connected = "yes"
            _w1.scrlLogs.insert(END, dtime() + "BITS=" + str(s_bits))

        time.sleep(1)  # Sleep for 1 second to reduce CPU usage

def dtime():
    now = datetime.now()
    s1 = now.strftime("%m/%d/%Y, %H:%M:%S")
    return ("[" + str(s1) + "] ")

def get_sensor():
    while not stop_event.is_set():
        global temperature, humidity, pressure, altitude
        with open("/home/hari/FT232H/bme280.txt", "r") as f:
            last_line = f.readlines()[-1]
            fields = last_line.split()
            lines = ' '.join(fields[2:10])
            temperature = fields[3][:5]
            humidity = fields[5][:5]
            pressure = fields[7][:7]
            altitude = fields[9][:4]

            # temperature
            _w1.txtTemperature.delete(0, END)  # Clear the existing text
            _w1.txtTemperature.insert(0, temperature + " " + u"\u2103")  # Insert the new temperature

            # humidity
            _w1.txtHumidity.delete(0, END)
            _w1.txtHumidity.insert(0, humidity + " %")

            # pressure
            _w1.txtPressure.delete(0, END)
            _w1.txtPressure.insert(0, pressure + " Pa")

            # altitude
            _w1.txtAltitude.delete(0, END)
            _w1.txtAltitude.insert(0, altitude + " MSL")

            # logs
            _w1.scrlLogs.insert(END, dtime() + lines.strip())
            _w1.scrlLogs.yview(END)
        time.sleep(1)

def telem_seq():
    # Read the current value from the file or set it to 0 if the file doesn't exist
    try:
        with open('/tmp/seq_py', 'r') as file:
            seq = int(file.read())
    except FileNotFoundError:
        seq = 0

    # Calculate the new value
    seq = (seq + 1) % 1000

    # Print the new value and update the file
    #print(seq)
    with open('/tmp/seq_py', 'w') as file:
        file.write(str(seq))
    return seq

def telem_param(parm):
    # Fill in empty channel names if there are fewer than 13
    call = "YD0BCX-13"
    call = (call + " " * (9 - len(call)))[:9]
    channel_names = parm.split()
    channel_names += [''] * (13 - len(channel_names))

    # Initialize the PARM message
    parm_message = ""

    # Iterate through channel names and add them to the PARM message
    for i, name in enumerate(channel_names):
        # If the previous PARM message is not empty and the current name is not empty
        if parm_message and name:
            parm_message += f",{name}"
        # If the previous PARM message is not empty and the current name is empty
        elif parm_message and not name:
            parm_message += ","
        # If the current name is not empty and the call sign is not empty
        elif name and call:
            parm_message += f":{call}:PARM.{name}"

    # Handle the special case where `""""` is between the `PARM` fields
    #    parm_message = parm_message.replace(",", "")
    parm_message = parm_message.replace(",,", ",,")
    parm_message = parm_message.replace("\"\"\"\"", "")

    # Remove the trailing comma if there are fewer than 13 channel names
    if len(sys.argv) < 15 and parm_message.endswith(','):
        parm_message = parm_message.rstrip(',')

    return parm_message

def telem_unit(unit):
    # Fill in empty channel names if there are fewer than 13
    call = "YD0BCX-13"
    call = (call + " " * (9 - len(call)))[:9]
    channel_names = unit.split()
    channel_names += [''] * (13 - len(channel_names))

    # Initialize the PARM message
    parm_message = ""

    # Iterate through channel names and add them to the PARM message
    for i, name in enumerate(channel_names):
        # If the previous PARM message is not empty and the current name is not empty
        if parm_message and name:
            parm_message += f",{name}"
        # If the previous PARM message is not empty and the current name is empty
        elif parm_message and not name:
            parm_message += ","
        # If the current name is not empty and the call sign is not empty
        elif name and call:
            parm_message += f":{call}:UNIT.{name}"

    # Handle the special case where `""""` is between the `PARM` fields
    #    parm_message = parm_message.replace(",", "")
    parm_message = parm_message.replace(",,", ",,")
    #parm_message = parm_message.replace("\"\"\"\"", "")

    # Remove the trailing comma if there are fewer than 13 channel names
    if len(channel_names) < 15 and parm_message.endswith(','):
        parm_message = parm_message.rstrip(',')

    parm_message = parm_message.replace("\"\"\"\"", "")
    return parm_message

def telem_eqns(eqns):
    call = "YD0BCX-13"
    call = (call + " " * (9 - len(call)))[:9]
    eqns = eqns.split()
    coefficients = eqns[1:]

    eqns_message = f":{call}:EQNS." + ",".join(coefficients)
    return eqns_message

def telem_data(data):
    data = data.split()
    values = ",".join(data[0:])

    #values_data = ascii_to_hex(f"T#{sequence},{values}")
    return values

def telem_bits(bits):
    # Separate out call and pad to 9 characters.
    #bits = bits.split()
    bits = shlex.split(bits)
    call = "YD0BCX-13"
    call = (call + "         ")[:9]

    bit_sense = bits[1]
    #print(bits)

    if not bit_sense.isdigit() or len(bit_sense) != 8:
        print("The bit-sense value must be 8 binary digits.")

    if len(bits) == 3:
        project_title = bits[2]
    else:
        project_title = ""

    return (f":{call}:BITS.{bit_sense},{project_title}")

def rand_bits(N):
    binary_string = "".join(str(random.randint(0, 1)) for _ in range(N))
    return binary_string

def ascii_to_hex(input_string):
    try:
        hex_string = binascii.hexlify(input_string.encode()).decode()
        return hex_string.upper()
    except Exception as e:
        print(f"Error: {e}")
        return None

    # Example usage:
    #input_string = "T#17,21,12,4,423,31,10101010"
    hexadecimal_representation = ascii_to_hex(input_string)
    return result

if __name__ == '__main__':
    BME280.start_up()




