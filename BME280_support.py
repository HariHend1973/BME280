#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    Oct 30, 2023 05:56:57 PM +07  platform: Windows NT

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *

import BME280
import ipaddress
import struct
import socket
import re
import string
import codecs
import random
import binascii
import os
import time
import threading
import shlex
from datetime import datetime
import subprocess

connected = "no"
s = socket.socket()
s_ipv4 = ''
s_port = 8001
stop_event = threading.Event()

temperature = ''
humidity = ''
pressure = ''
altitude = ''

KISS_FEND = 0xC0  # Frame start/end marker
KISS_FESC = 0xDB  # Escape character
KISS_TFEND = 0xDC  # If after an escape, means there was an 0xC0 in the source message
KISS_TFESC = 0xDD  # If after an escape, means there was an 0xDB in the source message

paths = [ "WIDE1-1" ]

_debug = True # False to eliminate debug printing from callback functions.

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = BME280.APRS_Telemetry(_top1)
    root.mainloop()

def connect(*args):
    global s_ipv4, s_port
    #if _debug:
    #    print('BME280_support.xxx')
    #    for arg in args:
    #        print ('    another arg:', arg)
    #    sys.stdout.flush()
    #_w1.scrlLogs.insert(END, "BME280_support.xxx")
    try:
        s_ipv4 = str(ipaddress.ip_address(_w1.txtKissIp.get()))
    except ValueError:
        s_ipv4 = "Wrong ipv4 format"
    if s_ipv4:
        _w1.scrlLogs.insert(END, dtime() + "IP: " + s_ipv4)

    try:
        s_port = _w1.txtKissPort.get()
        s_port = int(s_port)
    except:
        s_port = 8001

    if _w1.txtKissIp.get() and _w1.txtKissPort.get():
        s = sockconnect(s_ipv4, s_port)
        return s
    else:
        pass

def sockconnect(s_ipv4, s_port):
    global s, connected, sensorpoll, sensorbcn
    if connected == "no":
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        try:
            s.connect((s_ipv4, s_port))
        except socket.error:
            _w1.scrlLogs.insert(END, dtime() + "Caught exception socket.errors")
        _w1.scrlLogs.insert(END, dtime() + "CONNECTED to, IP " + s_ipv4 + " PORT: " + str(s_port))
        _w1.btnConnect.configure(text='''Disconnect''')
        connected = "yes"
        stop_event.clear()
    elif connected == "yes":
        _w1.btnConnect.configure(text='''Connect''')
        _w1.scrlLogs.insert(END, dtime() + "DISCONNECTED")
        connected = "no"
        stop_event.set()
    sensorpoll = threading.Thread(target=get_sensor)
    sensorbcn = threading.Thread(target=sendbcn)
    sensorpoll.daemon = True
    sensorbcn.daemon = True
    sensorpoll.start()
    sensorbcn.start()
    return (s, connected)

def sendbcn():
    global s, connected, s_ipv4, s_port, my_bcn, temperature, humidity, pressure
    old_t=time.time()
    aprs_cmd = '/home/hari/BME280/tx.py'
    while not stop_event.is_set():
        bcnInterval = 600

        if time.time()-old_t > bcnInterval:
            s_seq = telem_seq()
            s_rand_bits = rand_bits(8)
            #my_position ="21303631302e3639532f31303635302e38384557"
            my_position = '''0610.69S/10650.88E_'''
            my_comment = ''' APRS wx/telemetry station using python'''
            bcn_pos = '!{} {}'.format(my_position, my_comment)
            parm=''':YD0BCX-13:PARM.Temperature,Humidity,Pressure,Altitude,,SW1,SW2,SW3,SW4,SW5,SW6,SW7,SW8'''
            unit=''':YD0BCX-13:UNIT.deg.C,%,Pa,MSL'''
            eqns=''':YD0BCX-13:EQNS.0,1,0,0,1,0,0,1,0,0,1,0,0,1,0'''
            bits=f''':YD0BCX-13:BITS.{s_rand_bits},YD0BCX telemetry station'''
            data =f"T#{s_seq},{temperature},{humidity},{pressure},{altitude},0000,11111111"

            wxoutput = generate_aprs_weather_string(temperature, humidity, pressure)

            s_strpos = "/" + generate_aprs_timestamp() + my_position + wxoutput + my_comment
            #s_strbcn=bytes.fromhex(telem_header + s_strpos + telem_tail)
            _w1.scrlLogs.insert(END, dtime() + "beacon position: " +  "/" + generate_aprs_timestamp() + my_position + wxoutput + my_comment)
            _w1.scrlLogs.insert(END, dtime() + "Beacon Interval: " + str(bcnInterval))

            # Get the KISS frame
            kiss_frame = encode_ui_frame("YD0BCX-13", "APZBME", s_strpos, *paths)

            # Connect to Dire Wolf listening on port 8001 on this machine and send the frame
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((s_ipv4, s_port))
            s.send(kiss_frame)
            s.close()
    
            #cmd_bcn = ['python', aprs_cmd, 'YD0BCX-13', 'APZBME', s_strpos, 'WIDE1-1']
            #subprocess.run(cmd_bcn)

            old_t=time.time()

            # PARM
            time.sleep(3)

            # Get the KISS frame
            kiss_frame = encode_ui_frame("YD0BCX-13", "APZBME", parm, *paths)

            # Connect to Dire Wolf listening on port 8001 on this machine and send the frame
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((s_ipv4, s_port))
            s.send(kiss_frame)
            s.close()

            #cmd_parm = ['python', aprs_cmd, 'YD0BCX-13', 'APZBME', parm, 'WIDE1-1']
            #subprocess.run(cmd_parm)

            _w1.scrlLogs.insert(END, dtime() + "PARM=" + parm)

            # UNIT
            time.sleep(3)

            kiss_frame = encode_ui_frame("YD0BCX-13", "APZBME", unit, *paths)

            # Connect to Dire Wolf listening on port 8001 on this machine and send the frame
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((s_ipv4, s_port))
            s.send(kiss_frame)
            s.close()

            #cmd_unit = ['python', aprs_cmd, 'YD0BCX-13', 'APZBME', unit, 'WIDE1-1']
            #subprocess.run(cmd_unit)


            _w1.scrlLogs.insert(END, dtime() + "UNIT=" + unit)

            # EQNS
            time.sleep(3)

            kiss_frame = encode_ui_frame("YD0BCX-13", "APZBME", eqns, *paths)

            # Connect to Dire Wolf listening on port 8001 on this machine and send the frame
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((s_ipv4, s_port))
            s.send(kiss_frame)
            s.close()

            #cmd_eqns = ['python', aprs_cmd, 'YD0BCX-13', 'APZBME', eqns, 'WIDE1-1']
            #subprocess.run(cmd_eqns)

            _w1.scrlLogs.insert(END, dtime() + "EQNS=" + eqns)

            # DATA
            time.sleep(3)

            kiss_frame = encode_ui_frame("YD0BCX-13", "APZBME", data, *paths)

            # Connect to Dire Wolf listening on port 8001 on this machine and send the frame
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((s_ipv4, s_port))
            s.send(kiss_frame)
            s.close()

            #cmd_data = ['python', aprs_cmd, 'YD0BCX-13', 'APZBME', data, 'WIDE1-1']
            #subprocess.run(cmd_data)

            _w1.scrlLogs.insert(END, dtime() + "DATA=" + data)

            # BITS
            time.sleep(3)

            kiss_frame = encode_ui_frame("YD0BCX-13", "APZBME", bits, *paths)

            # Connect to Dire Wolf listening on port 8001 on this machine and send the frame
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((s_ipv4, s_port))
            s.send(kiss_frame)
            s.close()

            #cmd_bits = ['python', aprs_cmd, 'YD0BCX-13', 'APZBME', bits, 'WIDE1-1']
            #subprocess.run(cmd_bits)

            _w1.scrlLogs.insert(END, dtime() + "BITS=" + bits)

            # STATUS
            time.sleep(3)

            status=">Uptime: " + uptime()
            kiss_frame = encode_ui_frame("YD0BCX-13", "APZBME", status, *paths)

            # Connect to Dire Wolf listening on port 8001 on this machine and send the frame
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((s_ipv4, s_port))
            s.send(kiss_frame)
            s.close()

        time.sleep(1)  # Sleep for 1 second to reduce CPU usage

def dtime():
    now = datetime.now()
    s1 = now.strftime("%m/%d/%Y, %H:%M:%S")
    return ("[" + str(s1) + "] ")

def uptime():

     try:
         f = open( "/proc/uptime" )
         contents = f.read().split()
         f.close()
     except:
        return "Cannot open uptime file: /proc/uptime"

     total_seconds = float(contents[0])

     # Helper vars:
     MINUTE  = 60
     HOUR    = MINUTE * 60
     DAY     = HOUR * 24

     # Get the days, hours, etc:
     days    = int( total_seconds / DAY )
     hours   = int( ( total_seconds % DAY ) / HOUR )
     minutes = int( ( total_seconds % HOUR ) / MINUTE )
     seconds = int( total_seconds % MINUTE )

     # Build up the pretty string (like this: "N days, N hours, N minutes, N seconds")
     string = ""
     if days > 0:
         string += str(days) + " " + (days == 1 and "day" or "days" ) + ", "
     if len(string) > 0 or hours > 0:
         string += str(hours) + " " + (hours == 1 and "hour" or "hours" ) + ", "
     if len(string) > 0 or minutes > 0:
         string += str(minutes) + " " + (minutes == 1 and "minute" or "minutes" ) + ", "
     string += str(seconds) + " " + (seconds == 1 and "second" or "seconds" )

     return string;

def get_sensor():
    while not stop_event.is_set():
        global temperature, humidity, pressure, altitude
        with open("/home/hari/FT232H/bme280.txt", "r") as f:
            last_line = f.readlines()[-1]
            fields = last_line.split()
            lines = ' '.join(fields[2:10])
            temperature = float(fields[3][:5])
            humidity = float(fields[5][:5])
            pressure = float(fields[7][:7])
            altitude = float(fields[9][:4])

            # temperature
            _w1.txtTemperature.delete(0, END)  # Clear the existing text
            _w1.txtTemperature.insert(0, str(temperature) + " " + u"\u2103")  # Insert the new temperature

            # humidity
            _w1.txtHumidity.delete(0, END)
            _w1.txtHumidity.insert(0, str(humidity) + " %")

            # pressure
            _w1.txtPressure.delete(0, END)
            _w1.txtPressure.insert(0, str(pressure) + " Pa")

            # altitude
            _w1.txtAltitude.delete(0, END)
            _w1.txtAltitude.insert(0, str(altitude) + " MSL")

            # logs
            _w1.scrlLogs.insert(END, dtime() + lines.strip())
            _w1.scrlLogs.yview(END)
        time.sleep(1)

def telem_seq():
    # Read the current value from the file or set it to 0 if the file doesn't exist
    try:
        with open('/tmp/seq_py', 'r') as file:
            seq = int(file.read())
    except FileNotFoundError:
        seq = 0

    # Calculate the new value
    seq = (seq + 1) % 1000

    # Print the new value and update the file
    #print(seq)
    with open('/tmp/seq_py', 'w') as file:
        file.write(str(seq))
    return seq

def telem_param(parm):
    # Fill in empty channel names if there are fewer than 13
    call = "YD0BCX-13"
    call = (call + " " * (9 - len(call)))[:9]
    channel_names = parm.split()
    channel_names += [''] * (13 - len(channel_names))

    # Initialize the PARM message
    parm_message = ""

    # Iterate through channel names and add them to the PARM message
    for i, name in enumerate(channel_names):
        # If the previous PARM message is not empty and the current name is not empty
        if parm_message and name:
            parm_message += f",{name}"
        # If the previous PARM message is not empty and the current name is empty
        elif parm_message and not name:
            parm_message += ","
        # If the current name is not empty and the call sign is not empty
        elif name and call:
            parm_message += f":{call}:PARM.{name}"

    # Handle the special case where `""""` is between the `PARM` fields
    #    parm_message = parm_message.replace(",", "")
    parm_message = parm_message.replace(",,", ",,")
    parm_message = parm_message.replace("\"\"\"\"", "")

    # Remove the trailing comma if there are fewer than 13 channel names
    if len(sys.argv) < 15 and parm_message.endswith(','):
        parm_message = parm_message.rstrip(',')

    return parm_message

def telem_unit(unit):
    # Fill in empty channel names if there are fewer than 13
    call = "YD0BCX-13"
    call = (call + " " * (9 - len(call)))[:9]
    channel_names = unit.split()
    channel_names += [''] * (13 - len(channel_names))

    # Initialize the PARM message
    parm_message = ""

    # Iterate through channel names and add them to the PARM message
    for i, name in enumerate(channel_names):
        # If the previous PARM message is not empty and the current name is not empty
        if parm_message and name:
            parm_message += f",{name}"
        # If the previous PARM message is not empty and the current name is empty
        elif parm_message and not name:
            parm_message += ","
        # If the current name is not empty and the call sign is not empty
        elif name and call:
            parm_message += f":{call}:UNIT.{name}"

    # Handle the special case where `""""` is between the `PARM` fields
    #    parm_message = parm_message.replace(",", "")
    parm_message = parm_message.replace(",,", ",,")
    #parm_message = parm_message.replace("\"\"\"\"", "")

    # Remove the trailing comma if there are fewer than 13 channel names
    if len(channel_names) < 15 and parm_message.endswith(','):
        parm_message = parm_message.rstrip(',')

    parm_message = parm_message.replace("\"\"\"\"", "")
    return parm_message

def telem_eqns(eqns):
    call = "YD0BCX-13"
    call = (call + " " * (9 - len(call)))[:9]
    eqns = eqns.split()
    coefficients = eqns[1:]

    eqns_message = f":{call}:EQNS." + ",".join(coefficients)
    return eqns_message

def telem_data(data):
    data = data.split()
    values = ",".join(data[0:])

    #values_data = ascii_to_hex(f"T#{sequence},{values}")
    return values

def telem_bits(bits):
    # Separate out call and pad to 9 characters.
    #bits = bits.split()
    bits = shlex.split(bits)
    call = "YD0BCX-13"
    call = (call + "         ")[:9]

    bit_sense = bits[1]
    #print(bits)

    if not bit_sense.isdigit() or len(bit_sense) != 8:
        print("The bit-sense value must be 8 binary digits.")

    if len(bits) == 3:
        project_title = bits[2]
    else:
        project_title = ""

    return (f":{call}:BITS.{bit_sense},{project_title}")

def rand_bits(N):
    binary_string = "".join(str(random.randint(0, 1)) for _ in range(N))
    return binary_string

def ascii_to_hex(input_string):
    try:
        hex_string = binascii.hexlify(input_string.encode()).decode()
        return hex_string.upper()
    except Exception as e:
        print(f"Error: {e}")
        return None

    # Example usage:
    #input_string = "T#17,21,12,4,423,31,10101010"
    hexadecimal_representation = ascii_to_hex(input_string)
    return result

def generate_aprs_weather_string(temperature, humidity, pressure):
    # Get the current date and time in the APRS format (ddhhmmz).
    #now = datetime.datetime.utcnow()
    #date_time = now.strftime("%d%H%Mz")

    #winds
    wind_str=f"000/000g000"

    # Format temperature with one decimal place (e.g., 25.5°C).
    temperature_f = celsius_to_fahrenheit(float(temperature))
    temperature_str = f"{temperature_f}"

    # Format humidity as a percentage.
    humidity_str = f"h{round(humidity)}"

    # Format pressure with one decimal place (e.g., 1013.2 hPa).
    rounded_pressure = round(pressure, 1)
    pressure_str = f"b{str(rounded_pressure).replace('.', '')}"

    # Combine the components to create the APRS weather string.
    aprs_weather_string = f"{wind_str}t{temperature_str}{humidity_str}{pressure_str}"

    return aprs_weather_string

def celsius_to_fahrenheit(celsius):
    fahrenheit = round((celsius * 9/5) + 32, 2)
    return "{:0>{}}".format(round(fahrenheit), 3)

def generate_aprs_timestamp():
    # Get the current UTC time
    utc_now = datetime.utcnow()

    # Format the timestamp in APRS format (YYMMDDhhmmss)
    aprs_timestamp = utc_now.strftime("%d%H%M")

    return aprs_timestamp + "z"  # Use only the first 6 characters and append 'Z'
    
#Encode KISS Call SSID Destination 
def encode_address(s, final):
    try:
        digi = False

        if "-" not in s:
            s = s + "-0"  # default to SSID 0
        if "*" in s:
            digi = True
            s = s.replace('*', '')

        call, ssid = s.split('-')
        
        if len(call) < 6:
            call = call + " " * (6 - len(call))  # pad with spaces
        
        encoded_call = [ord(x) << 1 for x in call[0:6]]
        encoded_ssid = (int(ssid) << 1) | 0b01100000 | (0b00000001 if final else 0)

        # Include the 7th bit in the SSID byte based on the 'digi' flag
        if digi:
            encoded_ssid |= 0x80

        return encoded_call + [encoded_ssid]
    
    except ValueError as e:
        print("Error encoding address:", e)

# Encode KISS Frame
def encode_ui_frame(source, destination, message, *paths):

    src_addr_final = not paths or (len(paths) == 1 and paths[0] == '')  # src_addr_final is True if no paths are provided
    src_addr = encode_address(source.upper(), src_addr_final)
    dest_addr = encode_address(destination.upper(), False)

    # Ensure paths is a list of strings
    if isinstance(paths, (tuple, list)) and len(paths) == 1 and isinstance(paths[0], str):
        paths = paths[0].split(',')
    elif not all(isinstance(path, str) for path in paths):
        print("Invalid paths format. Returning None.")
        return None

    encoded_paths = [] if not paths or paths[0] == '' else [encode_address(path.upper(), final) for final, path in zip([False] * (len(paths) - 1) + [True], paths)]

    c_byte = [0x03]
    pid = [0xF0]
    msg = [ord(c) for c in message]

    packet = dest_addr + src_addr + sum(encoded_paths, []) + c_byte + pid + msg

    packet_escaped = []
    for x in packet:
        if x == KISS_FEND:
            packet_escaped.append(KISS_FESC)
            packet_escaped.append(KISS_TFEND)
        elif x == KISS_FESC:
            packet_escaped.append(KISS_FESC)
            packet_escaped.append(KISS_TFESC)
        else:
            packet_escaped.append(x)

    kiss_cmd = 0x00
    kiss_frame = [KISS_FEND, kiss_cmd] + packet_escaped + [KISS_FEND]

    kiss_frame = bytes(kiss_frame)
        
    return kiss_frame

if __name__ == '__main__':
    BME280.start_up()


